# Мультимодальная рекомендательная система для NFT

Эта система представляет собой передовое решение для рекомендации невзаимозаменяемых токенов (NFT) на основе их визуальных и текстовых характеристик. Система использует мультимодальные эмбеддинги (комбинация визуальных и текстовых представлений) для обеспечения точных и персонализированных рекомендаций.

## Ключевые особенности

- **Мультимодальные эмбеддинги**: Использование модели CLIP для визуальных характеристик и SentenceTransformers для текстовых, что обеспечивает глубокое понимание контента
- **Расширенные режимы поиска**: Возможность искать по изображению, тексту или комбинированно с настраиваемыми весами
- **Система обратной связи**: Встроенная система учета взаимодействий пользователей для улучшения рекомендаций со временем
- **Диверсификация результатов**: Автоматическое обеспечение разнообразия в рекомендациях
- **Авто-тегирование**: Автоматическая генерация тегов на основе анализа изображений и текстовых описаний
- **Векторное хранилище на базе FAISS**: Высокоэффективное хранение и поиск векторов с поддержкой различных типов индексов

## Архитектура системы

### Компоненты

- **Энкодеры (App/encoders.py)**:

  - `AdvancedEncoder` - комбинирует визуальные (CLIP) и текстовые (SentenceTransformers) представления
  - Создает эмбеддинги размерностью 1280 (512 для изображений + 768 для текста)

- **Векторное хранилище (App/index.py)**:

  - `VectorIndex` - обертка над FAISS с персистентностью метаданных
  - Поддерживает различные типы индексов (Flat, IVF, HNSW, PQ)
  - Позволяет добавлять, удалять и искать элементы

- **Система обратной связи (App/index.py)**:

  - `FeedbackSystem` - учитывает клики, добавления в избранное и покупки
  - Адаптирует рекомендации под предпочтения пользователей
  - Поддерживает связи между элементами (item-to-item рекомендации)

- **API слой (App/routes.py)**:
  - FastAPI маршруты для взаимодействия с системой
  - Документация через Swagger/OpenAPI

### Процесс рекомендации

1. **Кодирование**: NFT изображения и описания преобразуются в многомерные векторы
2. **Индексация**: Векторы сохраняются в FAISS для эффективного поиска по сходству
3. **Поиск**: При запросе новый вектор сравнивается со всеми векторами в индексе
4. **Переранжирование**: Результаты переранжируются с учетом обратной связи, разнообразия и персонализации
5. **Ответ**: Наиболее релевантные элементы возвращаются с оценками сходства

## Начало работы

### Системные требования

- Python 3.8+
- CUDA-совместимая видеокарта (опционально, для ускорения)

### Установка

```bash
# Клонировать репозиторий
git clone [url-репозитория]
cd [директория-проекта]

# Создать виртуальное окружение
python -m venv .venv
source .venv/bin/activate   # Linux/Mac
.venv\Scripts\activate      # Windows

# Установить зависимости
pip install -r requirements.txt
```

### Генерация синтетических данных

Перед обучением и тестированием системы необходимо сгенерировать набор синтетических данных:

```bash
# Генерация 1000 NFT изображений и метаданных
python generate_training_data.py --count 1000 --output synthetic_dataset --split_ratio 0.8
```

Параметры:

- `--count`: Количество изображений (по умолчанию 1000)
- `--output`: Директория для сохранения набора (по умолчанию "synthetic_dataset")
- `--split_ratio`: Соотношение данных для обучения/тестирования (по умолчанию 0.8)

Скрипт создаст следующую структуру директорий:

```
synthetic_dataset/
├── images/       # Сгенерированные изображения
├── train/        # Тренировочные данные (80%)
└── test/         # Тестовые данные (20%)
```

### Обучение рекомендательной системы

После генерации данных можно обучить рекомендательную систему:

```bash
python train_recommender.py --dataset synthetic_dataset --output recommender_results
```

Параметры:

- `--dataset`: Директория с набором данных (по умолчанию "synthetic_dataset")
- `--output`: Директория для сохранения результатов (по умолчанию "recommender_results")
- `--index_file`: Имя файла для векторного индекса (по умолчанию "recommender_index.faiss")
- `--meta_file`: Имя файла для метаданных (по умолчанию "recommender_meta.json")
- `--feedback_file`: Имя файла для данных обратной связи (по умолчанию "recommender_feedback.json")

Этот скрипт выполнит:

1. Загрузку тренировочных и тестовых данных
2. Обучение рекомендательной системы (добавление векторов в индекс)
3. Оценку качества рекомендаций на тестовой выборке
4. Тестирование персонализации рекомендаций
5. Генерацию метрик и визуализаций

### Автоматическое обновление модели

Для упрощения процесса обновления рекомендательной системы предусмотрен специальный скрипт, который автоматизирует весь процесс - от генерации новых данных до обновления базы:

```bash
# Простое обновление с параметрами по умолчанию
python update_model.py

# Создание резервной копии и сохранение обратной связи
python update_model.py --backup --preserve_feedback
```

Скрипт выполняет три основных шага:

1. Генерирует синтетические данные
2. Обучает модель на этих данных
3. Обновляет базу данных, при необходимости сохраняя обратную связь пользователей

#### Параметры скрипта update_model.py

**Параметры генерации данных:**

- `--count`: Количество синтетических NFT (по умолчанию: 1000)
- `--dataset`: Директория для сохранения сгенерированных данных (по умолчанию: "synthetic_dataset")
- `--split_ratio`: Соотношение тренировочных и тестовых данных (по умолчанию: 0.8)

**Параметры обучения модели:**

- `--output`: Директория для сохранения результатов обучения (по умолчанию: "recommender_results")
- `--index_file`: Имя файла для векторного индекса (по умолчанию: "recommender_index.faiss")
- `--meta_file`: Имя файла для метаданных (по умолчанию: "recommender_meta.json")
- `--feedback_file`: Имя файла для данных обратной связи (по умолчанию: "recommender_feedback.json")

**Дополнительные опции:**

- `--backup`: Создать резервную копию текущей базы данных
- `--backup_dir`: Директория для резервных копий (по умолчанию: "backups")
- `--preserve_feedback`: Сохранить существующие данные обратной связи пользователей
- `--skip_generation`: Пропустить генерацию синтетических данных
- `--skip_training`: Пропустить обучение модели

#### Примеры использования

```bash
# Обновление с большим количеством данных и сохранением обратной связи
python update_model.py --count 2000 --backup --preserve_feedback

# Обновление только базы данных без генерации новых данных
python update_model.py --skip_generation

# Создание новой базы с 5000 NFT без сохранения старой обратной связи
python update_model.py --count 5000 --backup
```

После успешного выполнения скрипта вы можете запустить API сервер:

```bash
uvicorn main:app --reload
```

### Бенчмаркинг производительности

Для оценки производительности различных типов индексов FAISS:

```bash
python benchmark_recommender.py --dataset synthetic_dataset --output benchmark_results --num_queries 50
```

Параметры:

- `--dataset`: Директория с набором данных (по умолчанию "synthetic_dataset")
- `--output`: Директория для сохранения результатов (по умолчанию "benchmark_results")
- `--num_queries`: Количество запросов для тестирования (по умолчанию 100)

Скрипт сравнит типы индексов (Flat и IVF100,Flat) по параметрам:

1. Время обучения
2. Скорость поиска при различных значениях k
3. Качество результатов (релевантность)
4. Соотношение скорость/качество

### Запуск API сервера

Для использования обученной модели через API:

1. Скопируйте файлы из директории с результатами обучения в директорию persist:

   ```bash
   # Создаем директорию persist, если она не существует
   mkdir -p persist

   # Копируем индекс, метаданные и данные обратной связи
   cp recommender_results/recommender_index.faiss persist/faiss.index
   cp recommender_results/recommender_meta.json persist/metadata.json

   # Создаем файл обратной связи, если его нет
   echo '{
     "clicks": {},
     "favorites": {},
     "purchases": {},
     "user_preferences": {},
     "item_similarity_boost": {}
   }' > persist/feedback.json
   ```

2. Запустите API сервер:

   ```bash
   uvicorn main:app --reload
   ```

3. Откройте Swagger UI для тестирования API:
   ```
   http://localhost:8000/docs
   ```

## API Endpoints

### Основные эндпоинты

| Эндпоинт        | Метод  | Описание                   | Параметры                                                                                                                                                                                                                                                                                       |
| --------------- | ------ | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `/items`        | POST   | Индексирование нового NFT  | `image`: Файл изображения<br>`description`: Текстовое описание<br>`name`: Имя (опционально)<br>`tags`: Теги через запятую (опционально)                                                                                                                                                         |
| `/recommend`    | POST   | Получение рекомендаций     | `image`: Изображение для поиска (опционально)<br>`description`: Текстовое описание (опционально)<br>`top_k`: Количество результатов (1-20)<br>`user_id`: ID пользователя для персонализации<br>`search_mode`: Режим поиска (visual/textual/balanced)<br>`diversify`: Диверсификация результатов |
| `/items/{uuid}` | GET    | Получение метаданных       | `uuid`: UUID элемента                                                                                                                                                                                                                                                                           |
| `/items/{uuid}` | DELETE | Удаление элемента          | `uuid`: UUID элемента                                                                                                                                                                                                                                                                           |
| `/feedback`     | POST   | Отправка обратной связи    | `item_uuid`: UUID элемента<br>`user_id`: ID пользователя<br>`feedback_type`: Тип (click/favorite/purchase/relation)<br>`value`: Значение (для определенных типов)                                                                                                                               |
| `/explore`      | GET    | Просмотр NFT               | `category`: Фильтр по категории<br>`style`: Фильтр по стилю<br>`tags`: Фильтр по тегам<br>`limit`: Лимит результатов<br>`offset`: Смещение для пагинации<br>`sort_by`: Поле для сортировки                                                                                                      |
| `/stats`        | GET    | Статистика индекса         | -                                                                                                                                                                                                                                                                                               |
| `/health`       | GET    | Проверка работоспособности | -                                                                                                                                                                                                                                                                                               |

### Примеры использования API

#### 1. Индексирование нового NFT

```bash
curl -X 'POST' \
  'http://localhost:8000/items' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'image=@path/to/image.jpg' \
  -F 'description=Уникальный цифровой арт в стиле киберпанк' \
  -F 'name=Cyber Dream #42' \
  -F 'tags=киберпанк,неон,будущее'
```

#### 2. Получение рекомендаций

```bash
curl -X 'POST' \
  'http://localhost:8000/recommend' \
  -H 'accept: application/json' \
  -H 'Content-Type: multipart/form-data' \
  -F 'description=футуристический киберпанк арт' \
  -F 'top_k=5' \
  -F 'search_mode=balanced' \
  -F 'diversify=true'
```

#### 3. Отправка обратной связи

```bash
curl -X 'POST' \
  'http://localhost:8000/feedback' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "item_uuid": "123e4567-e89b-12d3-a456-426614174000",
  "user_id": "user_12345",
  "feedback_type": "favorite"
}'
```

## Детали реализации и настройка

### Конфигурация системы (App/config.py)

Система имеет широкие возможности настройки через файл `App/config.py`:

- **Модели для энкодинга**:

  - `VISION_MODEL`: Модель для визуальных эмбеддингов (по умолчанию "openai/clip-vit-base-patch32")
  - `TEXT_MODEL`: Модель для текстовых эмбеддингов (по умолчанию "all-mpnet-base-v2")

- **Веса для поиска**:

  - `SearchWeights.IMAGE_WEIGHT`: Вес изображения при создании эмбеддинга (0.4)
  - `SearchWeights.TEXT_WEIGHT`: Вес текста при создании эмбеддинга (1.0)
  - `SearchWeights.VISUAL_WEIGHT`: Вес визуального сходства (0.35)
  - `SearchWeights.TEXTUAL_WEIGHT`: Вес текстового сходства (0.40)
  - `SearchWeights.TAG_WEIGHT`: Вес сходства по тегам (0.25)

- **Типы индексов FAISS**:

  - `FAISS_INDEX_TYPE`: Тип индекса FAISS ("Flat", "IVF100,Flat", "HNSW", "PQ")

- **Параметры обратной связи**:

  - `FEEDBACK_TYPES`: Словарь типов обратной связи и их весов
  - `FEEDBACK_DECAY_DAYS`: Количество дней до уменьшения влияния обратной связи вдвое

- **Параметры диверсификации**:
  - `DIVERSIFICATION_CONFIG`: Настройки для обеспечения разнообразия результатов

### Метрики оценки качества

Для оценки качества рекомендаций используются следующие метрики:

- `relevance_ratio`: Доля релевантных результатов среди всех рекомендаций
- `category_match_ratio`: Доля рекомендаций с совпадающими категориями
- `style_match_ratio`: Доля рекомендаций с совпадающими стилями
- `tag_match_ratio`: Доля рекомендаций с совпадающими тегами
- `mean_avg_precision`: Средняя точность рекомендаций

Для оценки персонализации:

- `user1_category_bias`, `user2_category_bias`: Смещение рекомендаций в сторону предпочтений пользователей
- `personalization_difference`: Степень различия между рекомендациями для разных пользователей

## Расширение системы

Благодаря модульной архитектуре систему можно легко расширить:

- **Новые энкодеры**: Добавьте новые энкодеры для других модальностей в директорию `App/encoders.py`
- **Другие бэкенды хранения**: Реализуйте альтернативные хранилища векторов
- **Стратегии переранжирования**: Создайте пользовательские стратегии ранжирования
- **Новые типы обратной связи**: Расширьте существующую систему обратной связи

## Устранение неполадок

- **Ошибка при обучении IVF индекса**: При наличии недостаточного количества данных для кластеризации используйте индекс типа Flat
- **Ошибки памяти GPU**: Уменьшите размер батча или используйте CPU версию FAISS (faiss-cpu)
- **Проблемы с запуском API**: Убедитесь, что все файлы (index, metadata, feedback) правильно скопированы в директорию persist

## Лицензия

[MIT License](LICENSE)
